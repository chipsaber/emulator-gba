<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<!--
The canvas element to be used in emulator-gba element

Example:

<emulator-canvas iodine={{iodine}} width="240", height="160"></emulator-canvas>

@demo demo/index.html
@hero hero.svg
-->

<dom-module id="emulator-canvas">
  <template>
    <canvas id="canvas" width={{width}} height={{height}}></canvas>
  </template>
  <script>
  Polymer({
    is: 'emulator-canvas',
    properties: {
      /**
      * Iodine emulator instance
      */
      iodine: Object,

      /**
      * `doSmoothing` texture filter the framebuffer?
      */
      doSmoothing: {
        type: Boolean,
        value: true
      },

      /**
      * `width` width of the screen
      * @type {[type]}
      */
      width: Number,

      /**
      * `height` height of the screen
      */
      height: Number,

      rgbCount: {
        type: Number,
        readOnly: true,
        computed: '_computeRgbCount(width, height)'
      },

      rgbaCount: {
        type: Number,
        readOnly: true,
        computed: '_computeRgbaCount(width, height)'
      },

    }

    // Observers
    observers: [
      '_processSmoothing(doSmoothing)'
    ];

    // Callbacks
    ready: function() {
      this._initializeVsync();
      this._initializeBuffers();
    },

    attached: function() {
      this._initializeCanvas();
    },

    // Private functions
    _computeRgbCount: function(width, height) {
      return width * height * 3;
    },

    _computeRgbaCount: function(width, height) {
      return width * height * 4;
    },

    _initializeVsync: function() {
      this._requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
      var parentObj = this;
      if (!this._requestAnimationFrame) {
        //Fallback timer eventing:
        setInterval(function () {
          parentObj._vsync();
        }, 16);
      }
      else {
        //Initialize the rAF eventing:
        this._requestAnimationFrame(
          function () {
            parentObj._vsync();
            parentObj._rAFKeepAlive();
          }
        )
      }
    },

    _initializeBuffers: function() {
      this._swizzledFrameFree = [
        getUint8Array(this.rgbCount),
        getUint8Array(this.rgbCount)
      ];
      this._swizzledFrameReady = [];
    },

    _vsync: function() {
      /*
      if (typeof this.gfxCallback == "function") {
        //Let the user supplied code prepare a frame or two:
        this.gfxCallback();
      }
      */
      //Draw a frame, if ready:
      this._requestDraw();
    },

    _rAFKeepAlive: function() {
      //Keep the vsync event requested:
      var parentObj = this;
      this._requestAnimationFrame(function () {
        parentObj._vsync();
        parentObj._rAFKeepAlive();
      });
    },

    _initializeCanvas: function() {
      //Obtain dimensional information:
      this._recomputeDimension();
      //Get handles on the canvases:
      this._canvasOffscreen = document.createElement("canvas");
      this._canvasOffscreen.width = this.width;
      this._canvasOffscreen.height = this.height;
      this._drawContextOffscreen = this.canvasOffscreen.getContext("2d");
      this._drawContextOnscreen = this.$.canvas.getContext("2d");
      //Initialize the canvas backing buffer:
      this._initializeCanvasBuffer();
    },

    _recomputeDimension: function() {
      this._canvasLastWidth = this.$.canvas.clientWidth;
      this._canvasLastHeight = this.$.canvas.clientHeight;
      if ((
        navigator.userAgent.toLowerCase().indexOf("gecko") != -1
        && navigator.userAgent.toLowerCase().indexOf("like gecko") == -1
      )) {    //Sniff out firefox for selecting this path.
        //Set target as unscaled:
        this._onscreenWidth = this.width;
        this._onscreenHeight = this.height;
      } else {
        //Set target canvas as scaled:
        this._onscreenWidth = this.width = this.$.canvas.clientWidth;
        this._onscreenHeight = this.height = this.$.canvas.clientHeight;
      }
    },

    _initializeCanvasBuffer: function() {
      //Get a CanvasPixelArray buffer:
      this._canvasBuffer = this._getBuffer(
        this._drawContextOffscreen,
        this.width,
        this.height
      );
      //Initialize Alpha Channel:
      this._initializeAlpha(this._canvasBuffer.data);
    },

    _getBuffer: function (canvasContext, width, height) {
      //Get a CanvasPixelArray buffer:
      var buffer = null;
      try {
        buffer = this._drawContextOffscreen.createImageData(width, height);
      } catch (error) {
        buffer = this._drawContextOffscreen.getImageData(0, 0, width, height);
      }
      return buffer;
    },

    _initializeAlpha:function (canvasData) {
      var length = canvasData.length;
      for (
        var indexGFXIterate = 3;
        indexGFXIterate < length;
        indexGFXIterate += 4
      ) {
        canvasData[indexGFXIterate] = 0xFF;
      }
    },

    _requestDraw: function() {
      if (this._swizzledFrameReady.length > 0) {
        var canvasData = this._canvasBuffer.data;
        var swizzledFrame = this._swizzledFrameReady.shift();
        for (
          var canvasIndex = 0, bufferIndex = 0;
          canvasIndex < this.rgbaCount;
          ++canvasIndex
        ) {
          canvasData[canvasIndex++] = swizzledFrame[bufferIndex++];
          canvasData[canvasIndex++] = swizzledFrame[bufferIndex++];
          canvasData[canvasIndex++] = swizzledFrame[bufferIndex++];
        }
        this._swizzledFrameFree.push(swizzledFrame);
        this._graphicsBlit();
      }
    },

    _graphicsBlit: function() {
      if (
        this._canvasLastWidth != this.$.canvas.clientWidth
        || this._canvasLastHeight != this.canvas.clientHeight
      ) {
        this._recomputeDimension();
        this._processSmoothing();
      }
      if (
        this.width == this._onscreenWidth
        && this.height == this._onscreenHeight
      ) {
        //Canvas does not need to scale, draw directly to final:
        this._drawContextOnscreen.putImageData(this._canvasBuffer, 0, 0);
      } else {
        //Canvas needs to scale, draw to offscreen first:
        this._drawContextOffscreen.putImageData(this._canvasBuffer, 0, 0);
        //Scale offscreen canvas image onto the final:
        this._drawContextOnscreen.drawImage(
          this._canvasOffscreen,
          0,
          0,
          this.onscreenWidth,
          this.onscreenHeight
        );
      }
    },

    _processSmoothing: function() {
      this.$.canvas.className = (this.doSmoothing) ? "textureSmooth" : "texturePixelated";
      this._drawContextOnscreen.mozImageSmoothingEnabled = this.doSmoothing;
      this._drawContextOnscreen.webkitImageSmoothingEnabled = this.doSmoothing;
      this._drawContextOnscreen.imageSmoothingEnabled = this.doSmoothing;
    }
  });
  </script>
</dom-module>
